%{
/*
 * Copyright 2010       Chris Heunen
 * Copyright 2010-2013  Aleks Kissinger
 * Copyright 2013       K. Johan Paulsson
 * Copyright 2013       Alex Merry <dev@randomguy3.me.uk>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#import <Foundation/Foundation.h>
#import "tikzparser.h"

%}

%option reentrant bison-bridge 8bit
%option nounput
%option yylineno
%option noyywrap
%option header-file="common/tikzlexer.h"

%s props
%s xcoord
%s ycoord
%s noderef

FLOAT \-?[0-9]*(\.[0-9]+)?

%%

\n.* {
	[yyextra newLineStarted:yytext+1];
	yyless(1);
}
<INITIAL,xcoord,ycoord,props,noderef>[ ]+  { [yyextra incrementPosBy:yyleng]; } /* ignore whitespace */;
<INITIAL,xcoord,ycoord,props,noderef>[\t]+ { [yyextra incrementPosBy:8*yyleng]; } /* ignore whitespace */;
\\begin\{tikzpicture\}         { [yyextra incrementPosBy:yyleng]; return BEGIN_TIKZPICTURE_CMD; }
\\end\{tikzpicture\}           { [yyextra incrementPosBy:yyleng]; return END_TIKZPICTURE_CMD; }
\\begin\{pgfonlayer\}          { [yyextra incrementPosBy:yyleng]; return BEGIN_PGFONLAYER_CMD; }
\\end\{pgfonlayer\}            { [yyextra incrementPosBy:yyleng]; return END_PGFONLAYER_CMD; }
\\draw                         { [yyextra incrementPosBy:yyleng]; return DRAW_CMD; }
\\node                         { [yyextra incrementPosBy:yyleng]; return NODE_CMD; }
\\path                         { [yyextra incrementPosBy:yyleng]; return PATH_CMD; }
rectangle                      { [yyextra incrementPosBy:yyleng]; return RECTANGLE; }
node                           { [yyextra incrementPosBy:yyleng]; return NODE; }
at                             { [yyextra incrementPosBy:yyleng]; return AT; }
to                             { [yyextra incrementPosBy:yyleng]; return TO; }
;                              { [yyextra incrementPosBy:yyleng]; return SEMICOLON; }

\([ ]*{FLOAT}[ ]*,[ ]*{FLOAT}[ ]*\) {
	[yyextra incrementPosBy:1];
	yyless(1);
	BEGIN(xcoord);
}
<xcoord>{FLOAT} {
	[yyextra incrementPosBy:yyleng];
	yylval->pt.x=(float)strtod(yytext,NULL);
	BEGIN(ycoord);
}
<ycoord>, { [yyextra incrementPosBy:yyleng]; }
<ycoord>{FLOAT} {
	[yyextra incrementPosBy:yyleng];
	yylval->pt.y=(float)strtod(yytext,NULL);
}
<ycoord>\) {
	[yyextra incrementPosBy:yyleng];
	BEGIN(INITIAL);
	return COORD;
}

 /* when we see "[", change parsing mode */
\[ /*syntaxhlfix]*/ {
	[yyextra incrementPosBy:yyleng];
	BEGIN(props);
	return LEFTBRACKET;
}
<props>= { [yyextra incrementPosBy:yyleng]; return EQUALS; }
<props>, { [yyextra incrementPosBy:yyleng]; return COMMA; }
<props>[^=,\{\] \t]([^=,\{\]]*[^=,\{\] \t])? {
	[yyextra incrementPosBy:yyleng];
	yylval->nsstr=[NSString stringWithUTF8String:yytext];
	return PROPSTRING;
}
<props>\] {
	[yyextra incrementPosBy:yyleng];
	BEGIN(INITIAL);
	return RIGHTBRACKET;
}

\( {
	[yyextra incrementPosBy:yyleng];
	BEGIN(noderef);
	return LEFTPARENTHESIS;
}
<noderef>\. {
	[yyextra incrementPosBy:yyleng];
	return FULLSTOP;
}
<noderef>[^\.\{\)]+ {
	[yyextra incrementPosBy:yyleng];
	yylval->nsstr=[NSString stringWithUTF8String:yytext];
	return REFSTRING;
}
<noderef>\) {
	[yyextra incrementPosBy:yyleng];
	BEGIN(INITIAL);
	return RIGHTPARENTHESIS;
}

<INITIAL,props>\{ {
	NSMutableString *buf = [NSMutableString string];
	unsigned int brace_depth = 1;
	unsigned int escape = 0;
	while (1) {
		char c = input(yyscanner);
		// eof reached before closing brace
		if (c == '\0' || c == EOF) yyterminate();

		if (escape) {
			escape = 0;
		} else if (c == '\\') {
			escape = 1;
		} else if (c == '{') {
			brace_depth++;
		} else if (c == '}') {
			brace_depth--;
			if (brace_depth == 0) break;
		}
		[buf appendFormat:@"%c", c];
	}
	
	NSString *s = [buf copy];
    yyleng += 1 + [buf length];
	[s autorelease];
	yylval->nsstr = s;
    [yyextra incrementPosBy:yyleng];
	return DELIMITEDSTRING;
}

 /* vi:ft=lex:noet:ts=4:sts=4:sw=4:
 */
